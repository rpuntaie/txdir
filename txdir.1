.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "txdir" "1" "" "Version 2.0.2" "txdir"
.SH NAME
\f[B]txdir\f[R] \[em] text tree from or to file tree
.SH SYNOPSIS
\f[B]txdir\f[R] [<infile>|<indir>|-] [<outdir>|-] [<options>]
.PP
Options:
.IP
.EX
-h: help
-v: version
-l: flat listing
-f: exclude files
-d: include dot files/directories
-n: exclude file content (don\[aq]t reapply such a tree as it will empty all files)
-m: maximum depth
-c: commands to create directories (from https://github.com/gcmt/mktree)
.EE
.PP
Files/dirs are ignored via .gitignore.
.PP
Command line help:
.IP
.EX
usage: txdir  [infile] [outdir] [-h] [-v] [-a] [-b] [-l] [-f] [-d] [-n] [-m M] [-c [C [C ...]]]

Files/dirs are ignored via .gitignore. If the directory contains unignored binary files, exclude
files with \[aq]-f\[aq] or ignoring content with \[aq]-n\[aq]. Text file content must not have an empty first
line.

positional arguments:
  infile          If a file, it is expected to contain a text representation of a directory, flat
                  or indented (none or - is stdin). If a directory, the text view is created with
                  file content (unless -n).
  outdir          None or - means printing to stdout. If the parameter is an existing file,
                  nothing is done. If not a directory, the directory is created. The file tree is
                  created in the directory.

optional arguments:
  -h              Print help information.
  -v              Print version information.
  -a              Use ASCII instead of unicode when printint the indented view.
  -b              Include content of binary files as base64 encoded.
  -l              Create a flat listing instead of an indented view.
  -f              Omit files. Only list directories.
  -d              Include dot files/directories.
  -n              Omit file content.
  -m M            Maximum directory depth to scan.
  -c [C [C ...]]  Directories described with a DSL (\[aq],\[aq] = end of token, \[aq].\[aq] = up dir, \[aq]/\[aq] = down)
                  \[ga]txdir - . -c \[aq]a/b/d.c/d..a/u,v,x,g\[rs].x\[aq]\[ga] produces the same as \[ga]mkdir -p
                  a/{b,c}/d a/u a/v a/x a/g.x\[ga] If not within \[aq], use \[rs]\[rs] to escape.
.EE
.SH DESCRIPTION
.IP \[bu] 2
Construct a \f[I]file tree\f[R] from a text tree.
.IP \[bu] 2
Construct a \f[I]text tree\f[R] from a file tree.
.PP
This allows to edit a whole file tree within one file first, without the
necessity to switch files.
.PP
The text tree can also be templated and first run through a tool like
stpl (https://github.com/rpuntaie/stpl) before being processed by
\f[CR]txdir\f[R] to produce the final file tree.
This usage is like
cookiecutter (https://github.com/cookiecutter/cookiecutter), only that
it has the tree definition in one file.
.SH INSTALLATION
To install for user only, do:
.IP
.EX
pip install --user txdir
.EE
.SH COMMAND USAGE
Without arguments it expects input from \f[CR]stdin\f[R]:
.IP
.EX
txdir
.EE
.PP
Exit this via \f[CR]CTRL+C\f[R].
Use no input argument only in combination with piping, or when using -c.
.PP
Use on a directory tree where
.IP \[bu] 2
binary text files are only in dotted directories (e.g.
\&.git) or
.IP \[bu] 2
binary files are ignored via \f[CR].gitignore\f[R]
.IP
.EX
txdir .
.EE
.PP
produces text output to \f[CR]stdout\f[R], similar to \f[CR]tree\f[R],
but with content, unless content is suppressed with \f[CR]-n\f[R].
.PP
You can save the output in a file and edit it:
.IP
.EX
txdir -l . > tmp.txt
.EE
.PP
The \f[CR]-l\f[R] option makes the output flat.
You can drop the \f[CR]-l\f[R], if you want \f[CR]tmp.txt\f[R] contain
an indented tree.
.PP
NO directory is created, unless a root is provided as second argument:
.IP
.EX
txdir tmp.txt .
.EE
.PP
This applies to the (edited) text tree in \f[CR]tmp.txt\f[R] on the
current directory.
.IP
.EX
txdir . again
.EE
.PP
produces the same tree below \f[CR]again\f[R], almost like a
\f[CR]cp -R . again\f[R].
But internally a text tree of the file tree is created and then applied
to the new location.
.PP
Note, that \f[B]text file content must not have an empty first
line\f[R].
.SS EXAMPLES
.IP
.EX
cd \[ti]/tmp
txdir -c r/a/x,y,z
   └─ r/
      └─ a/
         ├─ x/
         ├─ y/
         └─ z/
txdir - . -c r/a/x,y,z
cd r
tree
   .
   └── a
       ├── x
       ├── y
       └── z
txdir .
   └─ a/
      ├─ x/
      ├─ y/
      └─ z/
txdir . > tmp.txt
#edit tmp.txt
cat tmp.txt
   ├─ a/
   │  ├─ x/
         ├─ x.txt
              This is content in x.txt
   │  ├─ y/
         ├─ y.txt
              This is content in y.txt
txdir tmp.txt .
txdir .
   ├─ a/
   │  ├─ x/
   │  │  └─ x.txt
               This is content in x.txt
   │  ├─ y/
   │  │  └─ y.txt
               This is content in y.txt
   │  └─ z/
   └─ tmp.txt
         ├─ a/
         │  ├─ x/
               ├─ x.txt
                    This is content in x.txt
         │  ├─ y/
               ├─ y.txt
                    This is content in y.txt
#Note, that what is below tmp.txt is content of tmp.txt, not actual directories.
#\[ga]txdir . | txdir - .\[ga] does not create the same tree below \[ga]\[ga]tmp.txt\[ga]\[ga],
#because tmp.txt exists as file and not as directory.
txdir a b
txdir . > tmp.txt
#edit tmp.txt adding {{txt}} and removing the tmp.txt line (else tmp.txt is emptied when applying)
cat tmp.txt
   ├─ a/
   │  ├─ x/
   │  │  └─ x.txt
   │  │        {{txt}} x.txt
   │  ├─ y/
   │  │  └─ y.txt
   │  │        {{txt}} y.txt
   │  └─ z/
   ├─ b/
   │  ├─ x/
   │  │  └─ x.txt
   │  │        {{txt}} x.txt
   │  ├─ y/
   │  │  └─ y.txt
   │  │        {{txt}} y.txt
   │  └─ z/
stpl tmp.txt - \[aq]txt=\[dq]Greeting from\[dq]\[aq] | txdir - .
rm tmp.txt
txdir . -l
   a/x/x.txt
      Greeting from x.txt
   a/y/y.txt
      Greeting from y.txt
   a/z/
   b/x/x.txt
      Greeting from x.txt
   b/y/y.txt
      Greeting from y.txt
   b/z/
txdir . -l | sed -e \[dq]s/ \[rs](.\[rs])\[rs].txt/ \[rs]1/g\[dq] | txdir - .
txdir . -l
   a/x/x.txt
      Greeting from x
   a/y/y.txt
      Greeting from y
   a/z/
   b/x/x.txt
      Greeting from x
   b/y/y.txt
      Greeting from y
   b/z/
.EE
.SH API USAGE
\f[CR]txtdir\f[R] is a python module.
.PP
Naming:
.IP \[bu] 2
\f[CR]view\f[R] refers to a text tree view
.IP \[bu] 2
\f[CR]flat\f[R] is a flat tree listing.
.IP \[bu] 2
\f[CR]tree\f[R] is the actual file tree
.PP
Functions:
.IP \[bu] 2
\f[CR]set_ascii\f[R], \f[CR]set_utf8\f[R]
.IP \[bu] 2
\f[CR]view_to_tree\f[R]
.IP \[bu] 2
\f[CR]tree_to_view\f[R]
.IP \[bu] 2
\f[CR]flat_to_tree\f[R]
.IP \[bu] 2
\f[CR]tree_to_flat\f[R]
.IP \[bu] 2
\f[CR]to_tree\f[R] decides whether \f[CR]flat_to_tree\f[R] or
\f[CR]view_to_tree\f[R] should be used
.IP \[bu] 2
\f[CR]main\f[R] makes the command line functionality accessible to
python
.PP
Class:
.PP
\f[CR]TxDir\f[R] can hold a file tree in memory.
Its \f[CR]content\f[R] represents
.IP \[bu] 2
\f[I]directory\f[R] if \f[I]list\f[R] of other \f[CR]TxDir\f[R]
instances
.IP \[bu] 2
\f[I]link\f[R] if \f[I]str\f[R] with path relative to the location as
link target
.IP \[bu] 2
\f[I]file\f[R] if \f[I]tuple\f[R] of text file lines
.PP
\f[CR]TxDir\f[R] methods:
.IP
.EX
__init__(self, name=\[aq]\[aq], parent=None, content=None)
__iter__(self) #leaves only
__lt__(self,other) #by name
__str__(self)
__repr__(self)
__call__ = cd
__truediv__(self, other) #changes and returns root
root(self)
path(self)
mkdir = cd #with content=[]
cd(self,apath,content=None) #cd or make node if content!=None
isfile(self)
isdir(self)
islink(self)
view(self)
flat(self)
create(self)
.EE
.PP
static:
.IP
.EX
fromcmds(descs)
fromview(viewstr)
fromflat(flatstr)
fromfs(root)
.EE
.SS EXAMPLES
.IP
.EX
>>> import os
>>> from os.path import expanduser
>>> from shutil import rmtree
>>> import sys
>>> from txdir import *

>>> os.chdir(expanduser(\[aq]\[ti]/tmp\[aq]))

>>> t = t.fromcmds([\[aq]r/a\[aq]])
>>> TxDir(\[aq]x.txt\[aq],t(\[aq]r/a\[aq]),(\[aq]Text in x\[aq],))
>>> t.view()
└─ r/
   └─ a/
      └─ x.txt
            Text in x
>>> t.flat()
r/a/x.txt
   Text in x

>>> rmtree(\[aq]r\[aq],ignore_errors=True)
>>> t.create()

>>> t = TxDir.fromfs(\[aq]r\[aq])
>>> t.view()
└─ a/
   └─ x.txt
         Text in x

>>> rmtree(\[aq]r\[aq],ignore_errors=True)
>>> r = TxDir.fromcmds([\[aq]r\[aq]])
>>> r = r(\[aq]r\[aq])/t(\[aq]a\[aq]) #root is returned
>>> t(\[aq]a\[aq]) == r(\[aq]r/a\[aq]) #r and t are roots
True
>>> r.flat()
r/a/x.txt
   Text in x
.EE
.SS License
MIT
